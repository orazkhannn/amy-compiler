package amyc
package codegen

import analyzer._
import ast.Identifier
import ast.SymbolicTreeModule.{Call => AmyCall, Div => AmyDiv, And => AmyAnd, Or => AmyOr, _}
import utils.{Context, Pipeline}
import wasm._
import Instructions._
import Utils._
import java.security.KeyStore
import java.net.PortUnreachableException

// Generates WebAssembly code for an Amy program
object CodeGen extends Pipeline[(Program, SymbolTable), Module] {
  def run(ctx: Context)(v: (Program, SymbolTable)): Module = {
    val (program, table) = v

    // Generate code for an Amy module
    def cgModule(moduleDef: ModuleDef): List[Function] = {
      val ModuleDef(name, defs, optExpr) = moduleDef
      // Generate code for all functions
      defs.collect { case fd: FunDef if !builtInFunctions(fullName(name, fd.name)) =>
        cgFunction(fd, name, false)
      } ++
      // Generate code for the "main" function, which contains the module expression
      optExpr.toList.map { expr =>
        val mainFd = FunDef(Identifier.fresh("main"), Nil, TypeTree(IntType), expr)
        cgFunction(mainFd, name, true)
      }
    }

    // Generate code for a function in module 'owner'
    def cgFunction(fd: FunDef, owner: Identifier, isMain: Boolean): Function = {
      // Note: We create the wasm function name from a combination of
      // module and function name, since we put everything in the same wasm module.
      val name = fullName(owner, fd.name)
      Function(name, fd.params.size, isMain){ lh =>
        val locals = fd.paramNames.zipWithIndex.toMap
        val body = cgExpr(fd.body)(locals, lh)
        if (isMain) {
          body <:> Drop // Main functions do not return a value,
                        // so we need to drop the value generated by their body
        } else {
          body
        }
      }
    }

    // Generate code for an expression expr.
    // Additional arguments are a mapping from identifiers (parameters and variables) to
    // their index in the wasm local variables, and a LocalsHandler which will generate
    // fresh local slots as required.
    def cgExpr(expr: Expr)(implicit locals: Map[Identifier, Int], lh: LocalsHandler): Code = {
      expr match {
        case Variable(name) => GetLocal(locals(name))
        case IntLiteral(value) => Const(value)
        case BooleanLiteral(value) => 
          if(value)
            Const(1)
          else
            Const(0)
        case StringLiteral(value) => mkString(value)
        case UnitLiteral() => Const(0)
        case Plus(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Add
        case Minus(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Sub
        case Times(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Mul
        case AmyDiv(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Div
        case Mod(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Rem
        case LessThan(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Lt_s
        case LessEquals(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Le_s
        case AmyAnd(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> And
        case AmyOr(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Or
        case Equals(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Eq
        case Concat(lhs, rhs) => cgExpr(lhs) <:> cgExpr(rhs) <:> Call(concatImpl.name)
        case Not(e) => cgExpr(e) <:> Eqz
        case Neg(e) => Const(0) <:> cgExpr(e) <:> Sub
        case Sequence(e1, e2) => cgExpr(e1) <:> Drop <:> cgExpr(e2)
        case Ite(cond, thenn, elze) => cgExpr(cond) <:> If_i32 <:> cgExpr(thenn) <:> Else <:> cgExpr(elze) <:> End
        case Error(msg) => mkString("Error: ") <:> cgExpr(msg) <:> Call(concatImpl.name) <:> Call("Std_printString") <:> Unreachable
        case Let(df, value, body) => 
          val localAdress = lh.getFreshLocal()
          cgExpr(value) <:> SetLocal(localAdress) <:> cgExpr(body)(locals + (df.name -> localAdress), lh)

        case AmyCall(qname, args) =>
          table.getConstructor(qname).orElse(table.getFunction(qname)) match {
            case Some(ConstrSig(argTypes, parent, index)) => 
              val allocBase = lh.getFreshLocal()
              val allocMemory: Code = GetGlobal(memoryBoundary) <:>
              SetLocal(allocBase) <:>
              GetGlobal(memoryBoundary) <:>
              adtField(args.size) <:>
              Add <:>
              SetGlobal(memoryBoundary)
              val storeTag: Code = GetLocal(allocBase) <:>
                Const(index) <:>
                Store 
              val storeArgs: Code = args.zipWithIndex.map((arg, idx) => 
                GetLocal(allocBase) <:>
                adtField(idx) <:>
                Add <:>
                cgExpr(arg) <:>
                Store
              )
              allocMemory <:> storeTag <:> storeArgs <:> GetLocal(allocBase)

            case Some(FunSig(argTypes, retType, owner)) => args.map(args => cgExpr(args)) <:> Call(fullName(owner, qname))
          }
        case Match(scrut, cases) =>
          def matchAndBind(code: Code, pat : Pattern): (Code, Map[Identifier, Int]) = {
            pat match{
              case WildcardPattern() => (code <:> Drop <:> Const(1), locals)
              case IdPattern(id) =>
                val binding = lh.getFreshLocal()
                (code <:> SetLocal(binding) <:> Const(1), locals + (id -> binding))
              case LiteralPattern(lit) => (code <:> cgExpr(lit) <:> Eq, locals)
              case CaseClassPattern(constr, args) =>
                val tagLocal = lh.getFreshLocal()
                val patternIdx = table.getConstructor(constr) match {case Some(sig) => sig.index}
                val compiledPatterns = args.map(arg => matchAndBind(GetLocal(tagLocal) <:> adtField(args.indexOf(arg)) <:> Load, arg))
                val argsCode: Code = (if(args.isEmpty) {Const(1)} else {compiledPatterns.map(_._1)} )
                (code <:>
                SetLocal(tagLocal) <:>
                GetLocal(tagLocal) <:>
                Load <:>
                Const(patternIdx) <:>
                Eq <:>
                If_i32 <:>
                argsCode <:> 
                Else <:>
                Const(0) <:>
                End, locals ++ compiledPatterns.flatMap(_._2))
            }
          }
          val scrutineeLocal = lh.getFreshLocal()
          val scrutineeCode = cgExpr(scrut) <:> SetLocal(scrutineeLocal)

          val caseBranches = cases.map { cs =>
            val (code, bindings) = matchAndBind(GetLocal(scrutineeLocal), cs.pat)
            code <:> If_i32 <:> (cgExpr(cs.expr)(bindings, lh)) <:> Else}

          scrutineeCode <:> caseBranches <:> mkString("Match error!") <:> Call("Std_printString") <:> Unreachable <:> cases.map(_ => End)
          // TODO
    }
  }

    Module(
      program.modules.last.name.name,
      defaultImports,
      globalsNo,
      wasmFunctions ++ (program.modules flatMap cgModule)
    )

  }
}
